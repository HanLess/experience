v8对js的执行管道如下：

#### 旧版：
 
 - 解析器生成AST 
 - full-codegen（基准编译器） 直接编译为机器码 
 - 执行 
 - 执行一段时间后，分析线程收集执行证据，编译器 crankshaft（优化编译器） 做代码优化
 - crankshaft 重新生成优化后的AST
 - crankshaft 将优化的AST编译成机器码
 - 继续执行

优点：

js被完全编译为高效的机器码，因为没有中间的字节码，所有执行不需要解释器

缺点：

- 一次把所有源码编译为机器码内存占用过大，有些函数即使只执行一次，也会编译为机器码，成本过高
- 缺少中间层的字节码，性能优化策略无法实施
- 老的编译器无法很好的支持新的js语法

#### 新版：

- 解析器生成 AST
- ignition 生成 bytecode 字节码，AST 被清除，释放内存
- 字节码被解释器执行（当前字节码大小，比等效的机器码体积减小 25% - 50%），解释器也是 ignition
- 运行过程中，解释器收集优化代码的信息
- 优化信息发送给编译器 Turbofan（优化编译器）
- Turbofan 编译出经过优化的机器码
- 随着函数执行，有些优化后的机器码，可能会被反编译成字节码


其中 parse 阶段和生成字节码阶段，另起线程执行，并不阻塞主线程

被反编译（deoptimization）的情况举例

```
function sum (x, y) {
  return x + y
}
```
最初几次调用，x 和 y 都是 int 类型，sum 函数被优化成机器码，之后调用 sum，传入的参数变成字符串，此时的机器码sum无法执行，所以进行反编译（deoptimization），退回为字节码，再执行。所以在写js代码的时候，也尽量按强类型的语言的习惯去写

优势：

 - 字节码的生成速度远大于机器码，js初始化执行速度更快
 - 编译成机器码时，不需要从AST开始，可以从中间层的字节码开始，且字节码反编译，也只需要回退到字节码

优化编译器策略：

- 函数只声明没有调用，则不会被解析成 AST
- 函数只被调用一次，bytecode 直接被执行，不会被编译成机器码
- 函数被多次调用，次函数被标记成热点函数，会被编译成机器码，之后再次调用，直接执行机器码




