最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，一般情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。


#### 浏览器渲染流程

（1）浏览器进程通过 safeBrowsing 判断是否是恶意站点，如站点内是否有恶意数据，ip 是否在谷歌黑名单中

（2）网络进程通过 IPC 管道将数据交给渲染进程开始渲染

（3）渲染进程收到 html ，主线程 开始解析 dom tree，收到 css 开始解析 css tree（样式的加载、解析不会阻塞主进程解析 dom tree，但是会阻塞渲染 dom，同时样式也会阻塞 js 的加载和执行）

（4）dom tree 和 css tree 是并行解析的，但是需要全部解析完成后，合成 render tree，render tree 用于渲染，所以样式的加载、解析会阻塞页面的渲染，但不会阻塞 dom 的解析，要分清区别

（5）主线程通过 dom tree 和 css tree 合成 render tree，并计算每个 render tree 节点在页面中的布局、大小、排版，这个阶段称为 layout，render tree 的每个节点，都记录了x，y坐标和尺寸

（6）dom tree 和 render tree 并不是一一对应的，比如 dom 节点 设置 display：none，则 render tree 上就没有这个节点，render tree 对应的是浏览器上展示的元素节点

（7）完成 layout 阶段，知道了每个节点的大小、位置，但是还需要知道以什么顺序来绘制（paint）这棵 render tree

（8）因为 z-index 会影响节点绘制的顺序层级，所以主线程会遍历 render tree，生成一个绘制记录表（paint record），这个表记录了绘制的顺序，这个阶段就是绘制（paint）

（9）render tree 创建完成后，主线程的工作就完成了，下一步就是 栅格化，此时会将 render tree 发送给 合成器线程

（10）合成器线程按规则分图层，把图层分割成更小的图块，交给栅格线程，进行栅格化

（11）图块的栅格化完成后，栅格线程会生成 draw quads（图块信息），交给 合成器线程

（12）合成器线程根据图块信息生成一个合成器帧，并将此合成器帧通过 IPC 通道交给浏览器进程，浏览器进程传到 GPU 进程，进行 GPU 渲染，整个页面就渲染完成了


主线程工作：dom tree，css tree，render tree 的解析

合成器线程：分图层，分割图块，合成器帧

栅格线程：图块栅格化，生成图块信息

重排：触发布局的变化，layout，paint 以及后面的流程重新执行；重绘：触发颜色等属性变化，不会触发重新布局，但还是会进行样式的重新计算

#### 优化手段

主线程中不光要进程 layout 和 paint，还要执行 js，所以有可能引发掉帧，造成页面卡顿

 - 利用 requestAnimationFrame，把 js 任务分割成小的任务块放在其中执行，react fiber 就是用了这种方法，这样就不会阻塞每一帧中的渲染任务
 - 利用 css 中的 transform 改变节点样式，不会触发重排重绘，只会重新进程栅格化，即不会占用主线程，只会占用 合成器线程 和 栅格线程，所以可以利用 transform 实现动画





