在 v8 中代码缓存分为资源缓存和编译缓存

资源缓存：强制缓存、协商缓存，这篇文章讲的很清楚

<a href="https://zhyjor.github.io/2018/01/11/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%BC%93%E5%AD%98%EF%BC%88%E7%86%9F%E6%82%89%E7%9A%84304%EF%BC%89/">http协议详解之一：缓存（熟悉的304）</a>

### 编译缓存

js 是解释型语言，即编译一行执行一行，v8 为了提速，会提前编译加载的 js 源码

v8编译 js 源码分三个步骤

  - 分词：把js源码字符串按一定规则分解，分解成有意义的代码块，叫词法单元，如 var a = 10 ，会被分解成 var,a,=,10
  - 解析：将词法单元构建成 ast，即抽象语法树
  - 代码生成：将 ast 转成可执行的代码

v8 对代码的缓存分两种：内存缓存 、磁盘缓存

#### 内存缓存（Isolate cache）

对于同一个 tab 加载的 js 源码，当V8编译该脚本时，已编译的字节码存储在哈希表中（在V8堆上），该哈希表由脚本的源代码键入。当Chrome浏览器要求V8编译另一个脚本时，V8首先检查该脚本的源代码是否与此哈希表中的任何内容匹配。如果是，我们只返回现有的字节码。这种内存缓存命中率高达80％

#### 磁盘缓存

内存缓存有一个缺陷 —— 无法进程间共享缓存，因为每个 tab 页都是独立的渲染进程，为了安全各个进程间相互独立。

磁盘缓存可以解决这个问题，磁盘缓存的过程如下：

 - 首次请求JS文件（即冷运行）时，Chrome 会下载该文件并将其提供给V8进行编译。它还将文件存储在浏览器的磁盘缓存中。
 - 当第二次请求JS文件（即热运行）时，Chrome从浏览器缓存中获取文件，然后再次将其提供给V8进行编译。<strong>但是，这一次，编译后的代码被序列化，并作为元数据附加到缓存的脚本文件中。</strong>
 - 第三次（即热运行），Chrome从缓存中获取了文件和文件的元数据，并将它们都交给了V8。V8反序列化元数据，并且可以跳过编译。

这里有一个关键点：两天内第二次编译的 js 源码，才会被磁盘缓存，第三次加载该 js 源码，则跳过编译

#### 针对浏览器缓存，可以做的优化手段

  - 少改代码
  - 不要更换网址
  - js 中有大量延迟编译的函数，如用到了 Math.random() 的函数，各种异步逻辑，事件监听等，这些函数都不会被预编译，而是执行时编译，所以，减少这类代码
  - 分离公共代码
  - 减少小于 1kb 的代码，因为chrome缓存的最小体积是 1kb
  - 避免使用内联脚本，内联脚本不会被预编译



