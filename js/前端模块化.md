首先明确加载的js文件的同步与异步方式：

同步：正常引入 <scirpt>，无 async,defer 标识

异步：其他，注意 document.createElement 动态创建 script 引入 js 文件，是一个异步行为！！

#### 模块化的唯一目的是功能模块解耦，需要的时候才引用。所以各个模块框架本质上解决的都是各个模块间如何引用的问题

#### 以下是对 AMD 与 CMD 模块引用的基本原理说明

### AMD

amd规范的思路是提前加载依赖模块，优点：尽早执行依赖可以尽早发现错误，实现简单；缺点：容易产生浪费

主要实现框架是 require.js

amd的思路很简单：

如果依赖什么模块，提前注明，require.js 会动态创建 script 标签把依赖模块引进来，然后通过一个状态值来判断所有模块是否都已经加载完，状态为true，执行回调

如何处理递归引用依赖：因为会在业务逻辑（回调）执行前，统一加载依赖，所以 require.js 处理循环依赖比较简单，遇到依赖就动态加载，onload后回调执行 factory方法（原型抽象出来，有点回调地狱的意思），也就保证了执行的顺序

ps：因为异步加载模块，为了处理引用多个模块，需要统一管理模块，并用状态值来判断所有模块是否已经全部加载

### CMD

cmd与amd的区别在于：不会提前引入依赖，而是随用随取。优点：防止资源浪费；缺点，实现复杂

要想实现在代码中引入，需要把 define 的 factory 函数 toString，然后正则匹配 require，如果发现有依赖，则加载、执行依赖后再执行 factory 中的逻辑

### CommonJs 与 es6 模块

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

对于 [CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。] 这个特点，当输出的是都是对象的时候，是一回事，可以用如下代码看出区别

#### ES6 

`
one.js

export var one = 0

setTimeout(function () {
    one = 10
}, 1000)

index.js

import { one } from './one.js'

console.log(one)

setTimeout(function() {
    console.log('---', one)
}, 2000)

输出 0
输出 --- 10
`

#### node

`
app.js
var one = 0

module.exports = one

setTimeout(function () {
    one = 10
}, 1000)

index.js

var one = require('./app');

console.log(one)

setTimeout(function () {
    console.log(one)
}, 2000)

输出 0
输出 0

`









