<!DOCTYPE html>
<html>
    <head>
    </head>
    <body>
        <video id="myVideo" src="" controls autoplay></video>

        <script>
            var video = document.querySelector('video');
            var position = 0 , buffer = null

            // http://localhost:8080/frag_bunny.mp4
            // http://nickdesaulniers.github.io/netfix/demo/frag_bunny.mp4
            
            var assetURL = 'http://localhost:8080/frag_bunny.mp4';
            // Need to be specific for Blink regarding codecs
            // ./mp4info frag_bunny.mp4 | grep Codec
            var mimeCodec = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';

            var mediaSource = new MediaSource();
            //console.log(mediaSource.readyState); // closed
            video.src = URL.createObjectURL(mediaSource);
            mediaSource.addEventListener('sourceopen', sourceOpen);

            var mysize , mytype

            const CONTAINER_BOXES = ['moov', 'trak', 'edts', 'mdia', 'minf', 'dinf', 'stbl']

            const SPECIAL_BOXES = ['udta', 'free']

            function readSize() {
                mysize = readFourByte()
                console.log(mysize)
            }

            function _readType() {
                var length = 4;
                var typeBuffer = []
                for (let i = 0; i < length; i++) {
                    typeBuffer.push(buffer[position++])
                }
                return String.fromCharCode.apply(null, typeBuffer)
            }

            function readType() {
                mytype = _readType()
                console.log(mytype)
                // 一个 box 的 size 只可能大于等于 8
                // 如果从 readSize 中解析出来的 mdat size 为 1，则表明此视频比较大，需要 type 后的 8 个字节来计算实际大小
                if (mysize === 1) {
                    mysize = readFourByte() << 32
                    mysize |= readFourByte()
                }
            }

            function readBody() {
                var data = buffer.slice(position, mysize)
                console.log(mytype , data)

                position += data.length
            }

            function sourceOpen () {
                //console.log(this.readyState); // open
                var mediaSource = this;
                var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
                fetchAB(assetURL, function (buf) {
                    buffer = new Uint8Array(buf);
                    var typeBuffer = [] 
                    console.log(buffer)
                    // read size
                    // var head4 = readFourByte()
                    // console.log(head4)

                    // // read type
                    // for (let i = 0; i < 4; i++) {
                    //     typeBuffer.push(buffer[position++])
                    // }
                    // var z = String.fromCharCode.apply(null, typeBuffer)
                    // console.log(z)


                    while (position < buffer.length) {
                        readSize()
                        readType()
                        readBody()
                    }
                    
                    sourceBuffer.addEventListener('updateend', function (_) {
                        mediaSource.endOfStream();
                    });
                    sourceBuffer.appendBuffer(buf);
                });
            };

            function fetchAB (url, cb) {
                var xhr = new XMLHttpRequest;
                xhr.open('get', url);
                xhr.responseType = 'arraybuffer';
                // xhr.setRequestHeader('Range', `bytes=0-2524488`)
                xhr.onload = function () {
                    cb(xhr.response);
                };
                xhr.send();
            };

            function readOneByte() {
                return buffer[position++] >>> 0
            }

            function readTwoByte() {
                return (
                ((buffer[position++] << 8) | buffer[position++]) >>> 0
                )
            }

            function readThreeByte() {
                return (
                ((buffer[position++] << 16) |
                    (buffer[position++] << 8) |
                    buffer[position++]) >>>
                0
                )
            }

            function readFourByte() {

                return (
                ((buffer[position++] << 24) |
                    (buffer[position++] << 16) |
                    (buffer[position++] << 8) |
                    buffer[position++]) >>>
                0
                )
            }
        </script>
    </body>
</html>