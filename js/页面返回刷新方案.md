背景：

需求中经常会遇到需要两个页面之间做联动的情况，比如：

<ul>
 <li>从列表页转跳到地址选择页，地址选择页进行了通用地址的更变，这时返回列表页时，因为通用地址做了更改，需要列表页进行刷新重新获取列表项的操作；</li>
 <li>从订单详情页点击评价进入到评价页面，当评价页面提交评价成功后，需要跳回到订单详情页，这时需要订单详情页展示评价的内容；</li>
</ul>

如果不用单页应用的方式实现，而只用两个不同页面A和B实现的话，以目前的方法，无论采取哪种，都会造成体验上的缺失：

<ul>
 <li>A页面通过a标签或location.href的方式打开B页面，B页面操作成功后，再通过a标签或location.href的方式打开一个新的A页面。这种情况会在history存在3个记录，用户从新的A页面点击返回按钮时，会从新的A页面→B页面→旧的A页面；</li>
 <li>A页面通过a标签或location.href的方式打开B页面，B页面操作成功后，用location.replace的方式打开新的A页面。缺点：history会存在2个记录，用户从新的A页面点击返回时，会从新的A页面→旧的A页面，虽然看不到B页面（地址选择页、评价输入页等），但还是会返回到旧的A页面，也会造成用户的困惑；而且在android到家webview中，replace仍然会保留之前页面的history；</li>
 <li>A页面直接通过location.replace打开B页面，B页面操作成功后，用location.replace的方式打开新的A页面。缺点：虽然只有一条记录，在新的A页面可以直接返回A页面的来源页，但由于B页面是replace A页面的，当用户不想操作B页面而只想返回到A页面时，A页面已经丢失了，会返回到A页面的来源页；且同样存在android到家webview中replace的问题；</li>
 <li>更好的方法是（如果不用单页面应用），从A页面正常打开B页面（a标签或location.href），当在B页面操作成功后，直接返回到A页面(histroty.back()/history.go(-1)/点击回退按钮)。但这时往往由于浏览器强大的缓存能力，展现的是缓存的旧的A页面，与我们预想的展示新的A页面不符。</li>
</ul>

#### 这时我们想到的，就是让A页面在监听到B页面的返回时，可以进行刷新操作。


用以下三个方法的结合，可以解决大部分机型缓存页面的问题。

#### 一、pageshow

在A页面用监听pageshow事件，当浏览器从B页面返回时，会执行pageshow的回调，我们在事件中使用location.reload()方法刷新A页面。网上的方案还会加上pagehide方法，以防pageshow不成功的情况，但在调研时发现只要支持pagehide的浏览器都支持会支持pageshow，所以暂时用pageshow就可以搞定了。

代码：

`
window.addEventListener('pageshow', function (evt) {
    if(evt.persisted){
        location.reload(true);
 }
});
`

支持的浏览器：

`
iOS：微信、safari、Chrome、Firefox、Yandex

Android：QQ浏览器、Firefox、UC、手机百度
`

这些浏览器中的A页面会完全地缓存下来，时刻监听pageshow/pagehide，当从B返回到A页面时，不会重新请求html文档，也不会重新执行js。（参见bfcache）
 
#### 二、借助前页面重新执行js的方法对比html文档版本号

有些浏览器不支持pageshow/pagehide，但这些浏览器大部分都会在A页面重新被展示时，虽然不会拉取html文档，但是会重新执行一遍A页面的js。这时我们可以借助重新执行js的机会，比较文档版本号（我们自己定义的），然后在判断是否是旧的A页面时，reload页面。

具体操作：

<ul>
 <li>给每个需要后退刷新的页面上加一个hidden input，存储页面在服务端的生成时间【需要后端支持】，作为页面的服务端版本号。</li>
 <li>并附加一段JS读取读取页面的版本号，同时也记录在浏览器/webview本地（cookie/localStorage/sessionStorage）进行存储，作为本地版本号。</li>
 <li>JS检查页面的服务端版本号和本地存储中的版本号，如果服务端版本号大于本地存储中版本号，说明页面是从服务端重新生成的；否则页面就是本地缓存的，即发生了后退行为。</li>
 <li>JS在监测到后退时，强制页面重新从服务端获取。</li>
</ul>

代码：

`
var SERVER_TIME = document.getElementById("SERVER_TIME");
var REMOTE_VER = SERVER_TIME && SERVER_TIME.value;
if(REMOTE_VER){
    var LOCAL_VER = sessionStorage && sessionStorage.PAGEVERSION;
 if(LOCAL_VER && parseInt(LOCAL_VER) >= parseInt(REMOTE_VER)){
        //说明html是从本地缓存中读取的
 location.reload(true);
 }else{
        //说明html是从server端重新生成的，更新LOCAL_VER
 sessionStorage.PAGEVERSION = REMOTE_VER;
 }
}
`

支持的浏览器：

`
iOS：UC、手机百度
Android：微信、Chrome、Yandex
 `
 
#### 三、Page Visibility API

通过以上两种方法的结合，可以覆盖到大部分浏览器。但有一些浏览器在A页面打开B页面的过程中，像是开了一个新的Webview来展示B页面的（小米自带浏览器尤其明显，虽然用户看到的还是同一个Tab），不会触发方法一和方法二。这时可以借助与浏览器Tab相关的Page Visibility API，含义大概为当用户最小化页面或者切换到另一个Tab时，将触发visibilitychange方法，并可以通过判断此时页面展示相关的属性（document.hidden 、document.visibilityState）来确定页面的显示状态。
于是当浏览器疑似用新开Webview的方式做页面A到页面B的转跳时（再次强调，用户看到的还是同一个Tab），页面A可以通过对visibilitychange事件，实现对返回的监听。

注：由于visibilitychange事件监听的是Tab之间的切换，所以当用户的浏览器打开了其它的Tab，并与页面A所处的Tab间来回切换时，或者切换到其它的APP又回到浏览器时，同理也会触发我们的监听事件。这时如果不做特殊处理，也会导致页面A的刷新。（可以在页面A转跳到页面B时记录一个字段在本地存储，并在visibilitychange中通过此字段判断是否是AB之间的转跳）

代码：

`
function handleVisibilityChange() {
    if (document.hidden) {
        // tab hidden
 } else {
        // tab show
  location.reload(true);
  }
}
document.addEventListener("visibilitychange", handleVisibilityChange, false);
`

支持的浏览器：

`
iOS：QQ浏览器
Android：小米自带浏览器
`

#### 结论

在调研的过程中，通过以上三个方法的结合，可以解决所有Android&iOS浏览器。可能还有没试到的浏览器会有不支持的情况，发现后会及时更新。
以上为页面返回刷新方案的调研结果，有了对页面返回动作的监听，除了单纯地对缓存页面进行刷新，也可以结合需求做其它的操作。
