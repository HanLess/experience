定义泛型类
```
public class test<T>{}
```
定义泛型方法
```
public static <T> String test(){}
```
### 泛型擦除

```
class HasF {
    public void f() {
        System.out.println("HasF.f()");
    }
}
public class Manipulator<T> {
    private T obj;

    public Manipulator(T obj) {
        this.obj = obj;
    }

    public void manipulate() {
        obj.f(); //无法编译 找不到符号 f()
    }

    public static void main(String[] args) {
        HasF hasF = new HasF();
        Manipulator<HasF> manipulator = new Manipulator<>(hasF);
        manipulator.manipulate();

    }
}
```
经过类型擦除后，Manipulator的类型变量T会被改成Object，所以无法确定obj的具体类型，无法得知obj是否有f方法，会编译报错

解决办法是 ```public class Manipulator<T>``` 改成 ```public class Manipulator<T extends HasF>```，这样擦除后obj的类型是 HasF 。

### 擦除后的问题

类型擦除导致泛型丧失了一些功能，任何在运行期需要知道确切类型的代码都无法工作

```
public class Erased<T> {
    private final int SIZE = 100;
    public static void f(Object arg) {
    if(arg instanceof T) {} // Error
    T var = new T(); // Error
    T[] array = new T[SIZE]; // Error
    T[] array = (T)new Object[SIZE]; // Unchecked warning
    }
}
```
通过 new T() 创建对象是不行的，一是由于类型擦除，二是由于编译器不知道 T 是否有默认的构造器。

解决办法（使用工厂模式）：
```
interface FactoryI<T> {
    T create();
}
class Foo2<T> {
    private T x;
    public <F extends FactoryI<T>> Foo2(F factory) {
    x = factory.create();
    }
    // ...
}
class IntegerFactory implements FactoryI<Integer> {
    public Integer create() {
    return new Integer(0);
    }
}
class Widget {
    public static class Factory implements FactoryI<Widget> {
        public Widget create() {
            return new Widget();
        }
    }
}
public class FactoryConstraint {
    public static void main(String[] args) {
        new Foo2<Integer>(new IntegerFactory());
        new Foo2<Widget>(new Widget.Factory());
    }
}
```
