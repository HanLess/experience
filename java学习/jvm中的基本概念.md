https://www.cnblogs.com/shudonghe/p/3457990.html

JIT：https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html


<h3>虚拟机的启动过程</h3>

加载 验证 准备 解析 初始化 使用 卸载

验证 准备 解析：称为连接过程

加载：将.class文件转换成二进制码，存在方法区，并在堆中创建相应的Class类，Class类是加载的最终产出，描述了此类的细节

验证：检查文件内容是否符合规范

准备：为static变量准备内存空间，存在方法区中

初始化：为静态变量初始化赋值

<h3>虚拟机中的内存</h3>

方法区：存放所有 class 类，static 变量，所有线程共享

方法区中的运行时常量池：运行时将 class 文件常量池加载到此区域，可以理解为class文件常量池的拷贝
（class文件常量池：是Class文件中的一部分。存储了类、方法、接口等中的常量，当然也包括字符串常量）

堆：存放所有类的实例对象，不会存储基本类型和对象引用，对所有线程共享

栈：存放方法中的局部变量（成员变量在堆区），以及对象的引用，
每个线程只包含一个栈区，并且为自身独有，其他栈不可以访问，存在多少个线程就有多少栈。
栈有3个部分：基本类型变量区、执行环境上下文、操作指令区。

栈帧：栈帧是栈的存储单元，每一个方法对应一个栈帧，栈中的栈帧以后进先出的方式存储，栈顶的栈帧是当前栈帧，对应的方法是当前方法

栈帧中的局部变量

栈帧中的操作数栈：栈帧中的工作区，也可以看成是运算时中间结果储存区，运行指令会把数据入栈或出栈，存储方式也是后入先出。

栈帧中的动态链接：动态链接指向这个栈帧对应的方法

栈帧中的返回地址：方法结束后，此栈帧出栈，在上层方法中继续执行，返回地址记录了应该在上层方法中继续执行的位置

综上可以看出，栈中存储的数据主要是局部变量，栈帧对应着一个方法的作用域


<h3>垃圾回收器</h3>

jvm中的gc只管理堆中的内存，栈中的栈帧会随着方法的执行入栈、出栈，不由gc管理

自动垃圾收集机制是查看堆内存、区分在使用的对象和未使用的对象、删除未使用的对象的一个过程

垃圾回收的步骤：标记（分代），删除（正常删除、带压缩的删除）

堆中的三代：年轻代 老年代 持久代（分代回收，优先回收年轻代，可以节省大量扫描-删除的时间）
