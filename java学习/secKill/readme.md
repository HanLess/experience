dao层的工作：接口设计和sql语句开发，逻辑代码和sql分离，所有业务逻辑在service层开发

service层：dto包，类似entity包，但entity存放的是业务的数据类实体（一个张表对应一个类），dto主要存放的是web与service之间的数据传递类

一、高并发优化（分布式）：

1 原子计数器（redis层）

2 记录行为消息（MQ消息队列）

3 落地（mysql数据层）

缺点：运维成本，稳定性，开发维护复杂，幂等性难以保证（重复秒杀），整体架构复杂

二、为什么不用mysql解决性能问题：

瓶颈分析：如果不用事务，mysql的性能并不差，但事务处理会造成大量阻塞，以秒杀事务举例（减库存，保存成功信息）

一个秒杀请求进来，执行事务的过程中，第二个请求线程要想执行此事务就需要等待（在减库存的时候，多个线程会操作同一条数据，所以mysql行级锁会上锁，后面的线程等待），就造成了block，在第一个线程的事务commit或rollback之前，

所有的线程都要排队，知道第一个线程的事务执行结束，此过程以此类推，所有的秒杀请求变成的串行处理。

瓶颈就在事务的处理：减库存 -> 执行mysql（网络延时），gc -> 保存成功信息 -> 执行mysql（网络延时），gc。这之间的所有网络与gc延时都会体现在线程等待的时间上

优化方向：因为行级锁会在事务commit之后释放，所以需要减少线程对行级锁的持有时间（网络和gc延迟）

判断减库存成功（update）：执行update语句没报错，影响mysql数据是1

优化思路：客户端逻辑放在mysql上，避免网络延迟和gc延迟

方案：存储过程（整个事务在mysql完成）

三、服务端缓存redis，进行高并发优化

redis中存储java对象，存的是二进制字符串，所以在jedis中的存、取操作，需要对java对象进行序列化，这里用了 protostuff 进行序列化操作
