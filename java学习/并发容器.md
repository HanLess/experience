### CopyOnWrite 

https://www.cnblogs.com/dolphin0520/p/3938914.html

###  Collections.synchronizedList()
可以将非线程安全容器转换成线程安全状态，在使用容器原生的方法时，可以保证原子性（通过封装一层，在方法外部加 synchronized 实现）

### Vector 

vector可以实现动态长度数组，每次扩容，默认长度翻倍

vector的线程安全功能，由加锁实现（synchronized）

### HashTable

hashTable实现同步的原理是加锁（synchronized）

### ConcurrentLinkedQueue 

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作（synchronized，ReentrantLock）

乐观锁：假设不会发生并发冲突，每次不加锁而是假设没有冲突而去完成某项操作，只在提交操作时检查是否违反数据完整性。如果因为冲突失败就重试，直到成功为止（CAS机制）

### ConcurrentHashMap

锁分段技术

HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。

### 13个原子操作类

乐观锁（CAS）

### CAS（compare and swap）

记录一块内存中的值为old，当经过一系列操作，得到一个新值new（想要把new存到这块内存中），这时候去比较old与这块内存中的值（取出新鲜的），如果相等，则把new存到内存中，否则不作操作

### 阻塞队列

	Throws exception	Special value	  Blocks	  Times out
	      
Insert	add(e)	         	offer(e)	  put(e)	  offer(e, time, unit).

Remove	remove()	        poll()	          take()	  poll(time, unit)

